---
title: "Java 内存模型"
layout: post
date: 2019-01-01 00:00
image: /assets/images/markdown.jpg
headerImage: false
tag:
- Java
- history note
category: blog
author: WuKongCoder
description: Java memory model
---
>以前博客文章，时间点无法追溯，统一放在 2019-01-01 00:00:00。

>为什么要用到Java内存模型?
个人理解，多线程之间涉及到共享变量，而根据书中提到的，线程的数据存在**本地内存**和**主内存**两处，有时共享变量要保证多个线程使用时数据的一致性，无论是本地内存还是主内存，对程序员来说是透明的，不用关心。这就需要Java在内存管理上，构建一个统一的模型，JMM(Java Memory Model)。

####**重排序:**
- 编译器优化的排序：不改变语义的前提，优化语句顺序。
- 指令集并行重排序：如果不存在数据依赖性，处理器可以改变语句对应的机器指令的执行顺序。
- 内存系统重排序：处理器使用缓存，使得数据的加载和存储看上去乱序执行。

从源代码顺序经过这三种排序才最后变成真正执行的指令。如果全凭各个编译器和处理器去排序，那代码真心不知道怎么写了……。
###**内存屏障：**
Java编译器在编译代码时会加入内存屏障指令，就是通过内存屏障来让处理器在特定类型下重排序（你任意排序，我代码怎么写啊）。
>为什么不按顺序执行，全部禁止重排序呢？
重排序是为了优化指令，更大程度上增强处理效率，不帮你优化，你执行起来不得慢的要死啊。

Java内存屏障指令分为四种：


[Java内存模型-木南天](http://www.cnblogs.com/uptownBoy/articles/1454441.html)
